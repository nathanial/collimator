import Collimator.Optics.Types
import Collimator.Optics.Iso
import Collimator.Optics.Lens
import Collimator.Optics.Traversal
import Collimator.Combinators
import Collimator.Poly
import CollimatorTests.Framework

namespace CollimatorTests.AdvancedShowcase.MindBending

open Collimator
open Collimator.Poly
open Collimator.Combinators
open scoped Collimator.Operators
open CollimatorTests

/-!
# Mind-Bending Examples

Showcase the most impressive and non-obvious capabilities:
- Self-referential optics (traversals that modify their own structure)
- Optics over functions (lenses into closures)
- Recursive traversals over tree-like structures
- Optics with phantom type parameters
- Van Laarhoven encoding tricks and equivalences
- "Impossible" seeming transformations made trivial
- Examples that would be very difficult without profunctor optics
-/

/-! ## Recursive Tree Structures -/

/-- Binary tree with values at leaves -/
inductive Tree (α : Type _) where
  | leaf : α → Tree α
  | node : Tree α → Tree α → Tree α
  deriving BEq, Repr

/-- Rose tree (n-ary tree) with values at nodes -/
inductive Rose (α : Type _) where
  | node : α → List (Rose α) → Rose α
  deriving BEq, Repr

instance [Inhabited α] : Inhabited (Rose α) where
  default := Rose.node default []

/-! ## Tree Traversals -/

/-- Applicative traversal over binary tree leaves -/
private def Tree.walk {α : Type _} {F : Type _ → Type _} [Applicative F]
    (f : α → F α) : Tree α → F (Tree α)
  | Tree.leaf a => pure Tree.leaf <*> f a
  | Tree.node l r =>
      pure Tree.node <*> Tree.walk f l <*> Tree.walk f r

/-- Depth-aware traversal over binary tree leaves -/
private def Tree.walkWithDepth {α : Type _} {F : Type _ → Type _} [Applicative F]
    (f : Nat → α → F α) (depth : Nat) : Tree α → F (Tree α)
  | Tree.leaf a => pure Tree.leaf <*> f depth a
  | Tree.node l r =>
      pure Tree.node <*> Tree.walkWithDepth f (depth + 1) l <*> Tree.walkWithDepth f (depth + 1) r

/-! Traversal for rose tree nodes (mutually recursive with walkList) -/
mutual
  private def Rose.walk {α : Type _} {F : Type _ → Type _} [Applicative F]
      (f : α → F α) : Rose α → F (Rose α)
    | Rose.node value children =>
        pure Rose.node <*> f value <*> Rose.walkList f children

  private def Rose.walkList {α : Type _} {F : Type _ → Type _} [Applicative F]
      (f : α → F α) : List (Rose α) → F (List (Rose α))
    | [] => pure []
    | x :: xs => pure List.cons <*> Rose.walk f x <*> Rose.walkList f xs
end

/-! Depth-aware traversal for rose tree nodes -/
mutual
  private def Rose.walkWithDepth {α : Type _} {F : Type _ → Type _} [Applicative F]
      (f : Nat → α → F α) (depth : Nat) : Rose α → F (Rose α)
    | Rose.node value children =>
        pure Rose.node <*> f depth value <*> Rose.walkListWithDepth f (depth + 1) children

  private def Rose.walkListWithDepth {α : Type _} {F : Type _ → Type _} [Applicative F]
      (f : Nat → α → F α) (depth : Nat) : List (Rose α) → F (List (Rose α))
    | [] => pure []
    | x :: xs => pure List.cons <*> Rose.walkWithDepth f depth x <*> Rose.walkListWithDepth f depth xs
end

/-! Polymorphic depth-aware traversal (allows type change) -/
mutual
  private def Rose.walkWithDepthPoly {α β : Type _} {F : Type _ → Type _} [Applicative F]
      (f : Nat → α → F β) (depth : Nat) : Rose α → F (Rose β)
    | Rose.node value children =>
        pure Rose.node <*> f depth value <*> Rose.walkListWithDepthPoly f (depth + 1) children

  private def Rose.walkListWithDepthPoly {α β : Type _} {F : Type _ → Type _} [Applicative F]
      (f : Nat → α → F β) (depth : Nat) : List (Rose α) → F (List (Rose β))
    | [] => pure []
    | x :: xs => pure List.cons <*> Rose.walkWithDepthPoly f depth x <*> Rose.walkListWithDepthPoly f depth xs
end

/-! ## Test Cases -/

/-- Test: Basic recursive traversal over binary tree -/
private def case_binaryTreeTraversal : TestCase := {
  name := "Binary tree: recursive traversal modifies all leaves",
  run := do
    let tr : Traversal' (Tree Int) Int := traversal Tree.walk

    -- Build a binary tree:       node
    --                            /    \
    --                         leaf(5) node
    --                                /    \
    --                            leaf(10) leaf(15)
    let tree := Tree.node
      (Tree.leaf 5)
      (Tree.node (Tree.leaf 10) (Tree.leaf 15))

    -- Transform all leaves
    let doubled := tree & tr %~ (· * 2)
    let expected := Tree.node
      (Tree.leaf 10)
      (Tree.node (Tree.leaf 20) (Tree.leaf 30))

    ensureEq "All leaves doubled" expected doubled

    -- Collect all leaf values using State monad
    let collectLeaves (x : Int) : StateT (List Int) Id Int := do
      modify (x :: ·)
      pure x

    let (_, leaves) := (traverse tr collectLeaves tree).run []
    ensureEq "All leaves collected" [5, 10, 15] leaves.reverse
}

/-- Test: Depth-aware recursive traversal using depth tracking -/
private def case_depthAwareTraversal : TestCase := {
  name := "Binary tree: depth-aware transformation using actual depth",
  run := do
    -- Create a tree with varying depths:
    --       node (depth 0)
    --       /           \
    --    leaf(1)      node (depth 1)
    --   depth 1       /         \
    --             leaf(2)     leaf(3)
    --            depth 2      depth 2
    let tree := Tree.node
      (Tree.leaf 1)
      (Tree.node (Tree.leaf 2) (Tree.leaf 3))

    -- Transform: add 100 * depth to each leaf value
    -- Leaf 1 is at depth 1: 1 + 100*1 = 101
    -- Leaf 2 is at depth 2: 2 + 100*2 = 202
    -- Leaf 3 is at depth 2: 3 + 100*2 = 203
    let addDepth (depth : Nat) (x : Int) : Id Int :=
      x + (100 * (depth : Int))

    let result := Tree.walkWithDepth addDepth 0 tree
    let expected := Tree.node
      (Tree.leaf 101)
      (Tree.node (Tree.leaf 202) (Tree.leaf 203))

    ensureEq "Values transformed by depth" expected result

    -- Verify we can also collect depth information
    let collectWithDepth (depth : Nat) (x : Int) : StateT (List (Nat × Int)) Id Int := do
      modify ((depth, x) :: ·)
      pure x

    let (_, depthInfo) := (Tree.walkWithDepth collectWithDepth 0 tree).run []
    ensureEq "Collected depth info" [(1, 1), (2, 2), (2, 3)] depthInfo.reverse
}

/-- Test: Rose tree (n-ary tree) recursive traversal -/
private def case_roseTreeTraversal : TestCase := {
  name := "Rose tree: n-ary recursive traversal with multiple children",
  run := do
    let tr : Traversal' (Rose String) String := traversal Rose.walk

    -- Build a rose tree:
    --          "root"
    --         /   |   \
    --      "a"   "b"  "c"
    --      /\         |
    --   "d" "e"      "f"

    let tree := Rose.node "root" [
      Rose.node "a" [
        Rose.node "d" [],
        Rose.node "e" []
      ],
      Rose.node "b" [],
      Rose.node "c" [
        Rose.node "f" []
      ]
    ]

    -- Transform all nodes to uppercase
    let upper := tree & tr %~ String.toUpper

    -- Verify root
    match upper with
    | Rose.node value children =>
      ensureEq "Root uppercase" "ROOT" value
      ensureEq "Three children" 3 children.length

      -- Verify first child
      match children.head? with
      | some (Rose.node value children) =>
        ensureEq "First child uppercase" "A" value
        ensureEq "First child has 2 children" 2 children.length
      | none => ensure false "Expected first child"

    -- Count all nodes using State
    let countNode (_x : String) : StateT Nat Id String := do
      modify (· + 1)
      pure _x

    let (_, count) := (traverse tr countNode tree).run 0
    ensureEq "Total node count" 7 count
}

/-- Test: Rose tree with deeply nested structure -/
private def case_deeplyNestedRoseTree : TestCase := {
  name := "Rose tree: deeply nested multi-way structure",
  run := do
    let tr : Traversal' (Rose Int) Int := traversal Rose.walk

    -- Build a deeply nested rose tree
    let deepTree := Rose.node 1 [
      Rose.node 2 [
        Rose.node 3 [],
        Rose.node 4 [
          Rose.node 5 []
        ]
      ],
      Rose.node 6 [
        Rose.node 7 [
          Rose.node 8 [],
          Rose.node 9 []
        ]
      ]
    ]

    -- Transform all values
    let multiplied := Traversal.over' tr (· * 10) deepTree

    -- Collect all values to verify transformation
    let collectValues (x : Int) : StateT (List Int) Id Int := do
      modify (x :: ·)
      pure x

    let (_, values) := (traverse tr collectValues multiplied).run []
    ensureEq "All values multiplied by 10" [10, 20, 30, 40, 50, 60, 70, 80, 90] values.reverse
}

/-- Test: Recursive validation with Option applicative -/
private def case_recursiveValidation : TestCase := {
  name := "Binary tree: recursive validation short-circuits on invalid node",
  run := do
    let tr : Traversal' (Tree Int) Int := traversal Tree.walk

    let tree1 := Tree.node
      (Tree.leaf 5)
      (Tree.node (Tree.leaf 10) (Tree.leaf 15))

    -- Validation: all values must be positive
    let validatePositive (x : Int) : Option Int :=
      if x > 0 then some x else none

    let result1 := traverse tr validatePositive tree1
    match result1 with
    | some t => ensureEq "Valid tree passes" tree1 t
    | none => ensure false "Expected validation to succeed"

    -- Tree with negative value - should fail
    let tree2 := Tree.node
      (Tree.leaf 5)
      (Tree.node (Tree.leaf (-10)) (Tree.leaf 15))

    let result2 := traverse tr validatePositive tree2
    match result2 with
    | none => pure ()  -- Expected: validation fails
    | some _ => ensure false "Expected validation to fail"
}

/-- Test: Recursive transformation with accumulating state -/
private def case_recursiveStatefulTransform : TestCase := {
  name := "Rose tree: compute running sum while transforming",
  run := do
    let tr : Traversal' (Rose Int) Int := traversal Rose.walk

    let tree := Rose.node 10 [
      Rose.node 20 [],
      Rose.node 30 [
        Rose.node 40 [],
        Rose.node 50 []
      ]
    ]

    -- Replace each value with the running sum and add current value to sum
    let replaceWithSum (x : Int) : StateT Int Id Int := do
      let sum ← get
      set (sum + x)
      pure sum

    let (transformed, finalSum) := (traverse tr replaceWithSum tree).run 0

    -- Values should be: [0, 10, 30, 60, 100]
    -- Transform: 10->0 (sum before), 20->10, 30->30, 40->60, 50->100
    ensureEq "Final sum" 150 finalSum

    -- Verify root was replaced with 0 (initial sum)
    match transformed with
    | Rose.node value _ =>
      ensureEq "Root replaced with initial sum" 0 value

    -- Collect all transformed values to verify the running sum transformation
    let collectTransformed (x : Int) : StateT (List Int) Id Int := do
      modify (x :: ·)
      pure x

    let (_, transformedValues) := (traverse tr collectTransformed transformed).run []
    ensureEq "All transformed values are running sums" [0, 10, 30, 60, 100] transformedValues.reverse
}

/-- Test: Composing recursive traversals -/
private def case_composedRecursiveTraversal : TestCase := {
  name := "Composed traversal: Tree of Options",
  run := do
    -- Create a tree where each leaf contains an Option
    let treeOfOptions : Tree (Option Int) := Tree.node
      (Tree.leaf (some 5))
      (Tree.node (Tree.leaf none) (Tree.leaf (some 15)))

    -- Compose tree traversal with option traversal
    let treeTr : Traversal (Tree (Option Int)) (Tree (Option Int)) (Option Int) (Option Int) :=
      traversal Tree.walk

    let optionTr : Traversal (Option Int) (Option Int) Int Int :=
      traversal (fun {F} [Applicative F] (f : Int → F Int) (opt : Option Int) =>
        match opt with
        | none => pure none
        | some a => pure some <*> f a)

    -- Compose: first traverse tree, then traverse options
    let composed := treeTr ∘ optionTr

    -- Transform: double all present values, skip None
    let doubled := treeOfOptions & composed %~ (· * 2)
    let expected := Tree.node
      (Tree.leaf (some 10))
      (Tree.node (Tree.leaf none) (Tree.leaf (some 30)))

    ensureEq "Composed traversal works" expected doubled

    -- Collect only present values
    let collectPresent (x : Int) : StateT (List Int) Id Int := do
      modify (x :: ·)
      pure x

    let (_, collected) := (traverse composed collectPresent treeOfOptions).run []
    ensureEq "Collected only present values" [5, 15] collected.reverse
}

/-- Test: Self-modifying recursive structure (mind-bending!) -/
private def case_selfModifyingTraversal : TestCase := {
  name := "Mind-bending: tree modifies itself - later nodes affected by earlier ones",
  run := do
    let tr : Traversal' (Rose Int) Int := traversal Rose.walk

    -- Create tree where traversal order matters
    -- Traversal visits: 5, 10, 15 (triggers!), 8, 3, 20, 2
    let tree := Rose.node 5 [
      Rose.node 10 [],
      Rose.node 15 [           -- This will trigger the "seen large" flag
        Rose.node 8 [],        -- These should be negated!
        Rose.node 3 []
      ],
      Rose.node 20 [           -- This stays positive (resets flag)
        Rose.node 2 []         -- This should be negated!
      ]
    ]

    -- Strategy: Once we see a large value (>12), negate all subsequent small values
    -- Large values themselves stay positive but keep the negation flag active
    let modifyBasedOnPrevious (x : Int) : StateT Bool Id Int := do
      let shouldNegate ← get
      if x > 12 then
        set true   -- Turn on negation for subsequent small values
        pure x     -- But large values themselves aren't negated
      else if shouldNegate then
        pure (-x)  -- Negate small values when flag is on
      else
        pure x     -- Before first large value, keep unchanged

    let (result, _) := (traverse tr modifyBasedOnPrevious tree).run false

    -- Verify the self-modification worked
    -- Expected structure after transformation (traversal order: 5,10,15,8,3,20,2):
    -- 5 (unchanged - before any large value)
    -- 10 (unchanged - before any large value)
    -- 15 (large value - turns on negation, stays 15)
    -- 8 (negated → -8, negation is active)
    -- 3 (negated → -3, negation still active)
    -- 20 (large value - keeps negation on, stays 20)
    -- 2 (negated → -2, negation still active)

    match result with
    | Rose.node root children =>
      ensureEq "Root: unchanged (before large value)" 5 root

      match children with
      | [Rose.node v1 c1, Rose.node v2 c2, Rose.node v3 c3] =>
        ensureEq "Child 1: unchanged (before large value)" 10 v1
        ensure (c1.isEmpty) "Child 1 has no children"

        ensureEq "Child 2: large value activates negation" 15 v2
        match c2 with
        | [Rose.node v2_1 _, Rose.node v2_2 _] =>
          ensureEq "Grandchild 2.1: negated after parent" (-8) v2_1
          ensureEq "Grandchild 2.2: still negated" (-3) v2_2
        | _ => ensure false "Expected 2 grandchildren under child 2"

        ensureEq "Child 3: large value stays positive" 20 v3
        match c3 with
        | [Rose.node v3_1 _] =>
          ensureEq "Grandchild 3.1: negated after parent" (-2) v3_1
        | _ => ensure false "Expected 1 grandchild under child 3"

      | _ => ensure false "Expected 3 children"

    -- Key insight: The State monad threads through the ENTIRE recursive traversal!
    -- Earlier nodes can affect how later (even deeply nested) nodes are transformed.
    -- This is "self-modification" - the tree's own values determine its transformation.
}

/-- Test: Deep recursive tree with actual depth tracking -/
private def case_deepRecursiveTree : TestCase := {
  name := "Deep tree: track and transform based on actual recursion depth",
  run := do
    -- Build a deep binary tree with leaves at different depths:
    --           node (depth 0)
    --          /              \
    --       node              node (depth 1)
    --      /    \            /    \
    --   leaf(1) leaf(2)   node   leaf(5)
    --  depth 2  depth 2  depth 2 depth 2
    --                    /    \
    --                 leaf(3) leaf(4)
    --                depth 3  depth 3
    let deepTree : Tree Int := Tree.node
      (Tree.node
        (Tree.leaf 1)
        (Tree.leaf 2))
      (Tree.node
        (Tree.node
          (Tree.leaf 3)
          (Tree.leaf 4))
        (Tree.leaf 5))

    -- Transform: multiply value by (depth + 1)
    -- Leaves at depth 2: multiply by 3
    -- Leaves at depth 3: multiply by 4
    let transformWithDepth (depth : Nat) (x : Int) : Id Int :=
      x * ((depth + 1) : Int)

    let result := Tree.walkWithDepth transformWithDepth 0 deepTree

    -- Collect values to verify correct depth-based transformation
    let collectValues (depth : Nat) (x : Int) : StateT (List (Nat × Int)) Id Int := do
      modify ((depth, x) :: ·)
      pure x

    let (_, depthValuePairs) := (Tree.walkWithDepth collectValues 0 deepTree).run []

    -- Verify depths: leaves 1,2,5 at depth 2; leaves 3,4 at depth 3
    ensureEq "Depth-value pairs collected" [(2, 1), (2, 2), (3, 3), (3, 4), (2, 5)] depthValuePairs.reverse

    -- Verify transformations based on depth
    let collectTransformed (_depth : Nat) (x : Int) : StateT (List Int) Id Int := do
      modify (x :: ·)
      pure x

    let (_, transformedValues) := (Tree.walkWithDepth collectTransformed 0 result).run []

    -- Verify: 1*3=3, 2*3=6, 3*4=12, 4*4=16, 5*3=15
    ensureEq "Values transformed by depth multiplier" [3, 6, 12, 16, 15] transformedValues.reverse
}

/-! ## The Census Transform - The "Impossible" Transformation -/

/-- Census data encoding global, local, and contextual information about each node -/
structure CensusData where
  rank : Nat           -- Sequential position in traversal order (0-indexed)
  depth : Nat          -- Distance from root (root = 0)
  totalSize : Nat      -- Total number of nodes in entire tree
  peersAtDepth : Nat   -- How many total nodes exist at this same depth level
  deriving BEq, Repr, Inhabited

/-- Collect depth histogram: how many nodes at each depth level -/
private def Rose.collectDepthHistogram {α : Type _}
    (depth : Nat) (tree : Rose α) : StateT (Array Nat) Id Unit := do
  match tree with
  | Rose.node _ children =>
    -- Increment count at this depth
    let counts ← get
    -- Extend array if needed
    let counts := if depth >= counts.size
                  then counts.append (Array.mkArray (depth + 1 - counts.size) 0)
                  else counts
    -- Increment count at this depth
    let counts := counts.set! depth (counts[depth]! + 1)
    set counts

    -- Recurse into children
    for child in children do
      Rose.collectDepthHistogram (depth + 1) child
termination_by sizeOf tree

/-- Helper: count total nodes in a tree -/
private def Rose.countNodes {α : Type _} (tree : Rose α) : Nat :=
  match tree with
  | Rose.node _ children =>
      1 + children.foldl (fun acc child => acc + Rose.countNodes child) 0
termination_by sizeOf tree

/-- The Census Transform test: encoding "impossible" global+local information -/
private def case_censusTransform : TestCase := {
  name := "Census Transform: Each node knows global size, local depth, traversal rank, and peer count",
  run := do
    -- Build a rose tree with interesting structure:
    --           "root" (depth 0, 1 node at this depth)
    --          /   |   \
    --       "a"  "b"  "c" (depth 1, 3 nodes at this depth)
    --       / \       |
    --     "d" "e"    "f" (depth 2, 3 nodes at this depth)
    --                  |
    --                 "g" (depth 3, 1 node at this depth)

    let tree := Rose.node "root" [
      Rose.node "a" [
        Rose.node "d" [],
        Rose.node "e" []
      ],
      Rose.node "b" [],
      Rose.node "c" [
        Rose.node "f" [
          Rose.node "g" []
        ]
      ]
    ]

    -- PHASE 1: Collect global statistics
    -- This seems impossible to do "in one pass" but profunctor optics make it elegant!

    -- Count total nodes
    let totalSize := Rose.countNodes tree
    ensureEq "Total tree size" 8 totalSize

    -- Collect depth histogram
    let (_, depthHistogram) := (Rose.collectDepthHistogram 0 tree).run #[]
    ensureEq "Depth histogram" #[1, 3, 3, 1] depthHistogram

    -- PHASE 2: Transform with ALL the information at once
    -- Each node receives: its depth (top-down), the global stats (closure),
    -- and generates its rank (sequential state)

    let censusTransform (depth : Nat) (_value : String) : StateT Nat Id CensusData := do
      let rank ← get
      set (rank + 1)
      pure {
        rank := rank,
        depth := depth,
        totalSize := totalSize,
        peersAtDepth := depthHistogram[depth]!
      }

    let (censusTree, finalRank) := (Rose.walkWithDepthPoly censusTransform 0 tree).run 0

    -- Verify traversal completed
    ensureEq "All nodes visited" 8 finalRank

    -- PHASE 3: Verify the "impossible" - each node has complete census data!

    -- Collect all census data to verify
    let collectCensus (_depth : Nat) (census : CensusData) : StateT (List CensusData) Id CensusData := do
      modify (census :: ·)
      pure census

    let (_, allCensus) := (Rose.walkWithDepth collectCensus 0 censusTree).run []
    let allCensus := allCensus.reverse

    -- Expected census data for each node in traversal order:
    -- root: rank=0, depth=0, total=8, peers=1
    -- a:    rank=1, depth=1, total=8, peers=3
    -- d:    rank=2, depth=2, total=8, peers=3
    -- e:    rank=3, depth=2, total=8, peers=3
    -- b:    rank=4, depth=1, total=8, peers=3
    -- c:    rank=5, depth=1, total=8, peers=3
    -- f:    rank=6, depth=2, total=8, peers=3
    -- g:    rank=7, depth=3, total=8, peers=1

    let expected : List CensusData := [
      { rank := 0, depth := 0, totalSize := 8, peersAtDepth := 1 },  -- root
      { rank := 1, depth := 1, totalSize := 8, peersAtDepth := 3 },  -- a
      { rank := 2, depth := 2, totalSize := 8, peersAtDepth := 3 },  -- d
      { rank := 3, depth := 2, totalSize := 8, peersAtDepth := 3 },  -- e
      { rank := 4, depth := 1, totalSize := 8, peersAtDepth := 3 },  -- b
      { rank := 5, depth := 1, totalSize := 8, peersAtDepth := 3 },  -- c
      { rank := 6, depth := 2, totalSize := 8, peersAtDepth := 3 },  -- f
      { rank := 7, depth := 3, totalSize := 8, peersAtDepth := 1 }   -- g
    ]

    ensureEq "Complete census data matches" expected allCensus

    -- THE PAYOFF: Query individual nodes to show they have "impossible" knowledge

    match censusTree with
    | Rose.node rootCensus children =>
      -- Root knows: "I'm first (rank 0), at top (depth 0), in an 8-node tree, alone at my level"
      ensureEq "Root knows its rank" 0 rootCensus.rank
      ensureEq "Root knows its depth" 0 rootCensus.depth
      ensureEq "Root knows total tree size" 8 rootCensus.totalSize
      ensureEq "Root knows it's alone at its depth" 1 rootCensus.peersAtDepth

      -- Check child 'a'
      match children[0]! with
      | Rose.node aCensus aChildren =>
        ensureEq "Node 'a' knows its rank" 1 aCensus.rank
        ensureEq "Node 'a' knows its depth" 1 aCensus.depth
        ensureEq "Node 'a' knows total size" 8 aCensus.totalSize
        ensureEq "Node 'a' knows there are 3 nodes at its depth" 3 aCensus.peersAtDepth

        -- Check grandchild 'd'
        match aChildren[0]! with
        | Rose.node dCensus _ =>
          ensureEq "Node 'd' knows its rank" 2 dCensus.rank
          ensureEq "Node 'd' knows its depth" 2 dCensus.depth
          ensureEq "Node 'd' knows there are 3 nodes at its depth" 3 dCensus.peersAtDepth

      -- Check the deepest node 'g'
      match children[2]! with
      | Rose.node _cCensus cChildren =>
        match cChildren[0]! with
        | Rose.node _fCensus fChildren =>
          match fChildren[0]! with
          | Rose.node gCensus _ =>
            ensureEq "Leaf 'g' knows it's last (rank 7)" 7 gCensus.rank
            ensureEq "Leaf 'g' knows it's deepest (depth 3)" 3 gCensus.depth
            ensureEq "Leaf 'g' knows it's alone at depth 3" 1 gCensus.peersAtDepth
            ensureEq "Leaf 'g' still knows total tree size" 8 gCensus.totalSize

    -- MIND-BENDING INSIGHT:
    -- Each node simultaneously knows:
    -- - Where it is in TIME (rank in traversal order - sequential state)
    -- - Where it is in SPACE (depth from root - top-down context)
    -- - GLOBAL facts (total tree size - external pre-computation)
    -- - HORIZONTAL knowledge (peers at same depth - requires full tree analysis)
    --
    -- This combines:
    -- - State threading (rank)
    -- - Parameter passing (depth)
    -- - Closure capture (global stats)
    -- - Multi-pass analysis (depth histogram)
    --
    -- All coordinated through the profunctor optics traversal!
}

def cases : List TestCase := [
  case_binaryTreeTraversal,
  case_depthAwareTraversal,
  case_roseTreeTraversal,
  case_deeplyNestedRoseTree,
  case_recursiveValidation,
  case_recursiveStatefulTransform,
  case_composedRecursiveTraversal,
  case_selfModifyingTraversal,
  case_deepRecursiveTree,
  case_censusTransform
]

end CollimatorTests.AdvancedShowcase.MindBending
